/*
Copyright 2015-2021 Gravitational, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: test.proto

package test

import (
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	validation "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	_ "google.golang.org/protobuf/types/known/wrapperspb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// Test (Test message definition.)
// └── str:string (Str string field)
// └── int32:int (Int32 int32 field)
// └── int64:int (Int64 int64 field)
// └── float:float64 (Float float field)
// └── double:float64 (Double double field)
// └── bool:bool (Bool bool field)
// └── bytes:string (Bytest byte[] field)
// └── timestamp:string (Timestamp time.Time field)
// └── duration_std:string (DurationStd time.Duration field (standard))
// └── duration_custom:string (DurationCustom time.Duration field (custom))
// └── timestamp_n:string (TimestampN *time.Time field)
// └── string_a:string (StringA []string field)
// └── bool_a:bool (BoolA []bool field)
// └── bytes_a:string (BytesA [][]byte field)
// └── timestamp_a:string (TimestampA []time.Time field)
// └── duration_custom_a:string (DurationCustomA []time.Duration field)
// └── nested (Nested nested message field)
// │   ├── str:string (Str string field)
// │   ├── nested (Nested repeated nested messages)
// │   │   ├── str:string (Str string field)
// │   ├── nested_m (Nested map repeated nested messages)
// │   │   ├── key:string
// │   │   ├── value:string
// │   ├── nested_m_obj (NestedMObj nested object map)
// │       └── key:string
// │       └── value
// │           └── str:string (Str string field)
// └── nested_a (NestedA nested message array)
// │   ├── str:string (Str string field)
// │   ├── nested (Nested repeated nested messages)
// │   │   ├── str:string (Str string field)
// │   ├── nested_m (Nested map repeated nested messages)
// │   │   ├── key:string
// │   │   ├── value:string
// │   ├── nested_m_obj (NestedMObj nested object map)
// │       └── key:string
// │       └── value
// │           └── str:string (Str string field)
// └── nested_m (NestedM normal map)
// │   ├── key:string
// │   ├── value:string
// └── nested_m_obj (NestedMObj object map)
//     └── key:string
//     └── value
//         └── str:string (Str string field)
//         └── nested (Nested repeated nested messages)
//         │   ├── str:string (Str string field)
//         └── nested_m (Nested map repeated nested messages)
//         │   ├── key:string
//         │   ├── value:string
//         └── nested_m_obj (NestedMObj nested object map)
//             └── key:string
//             └── value
//                 └── str:string (Str string field)

// SchemaTest returns schema for Test
//
// Test message definition.
func SchemaTest() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		// Str string field
		"str": {
			Type:        schema.TypeString,
			Description: "Str string field",
			Optional:    true,
		},
		// Int32 int32 field
		"int32": {
			Type:        schema.TypeInt,
			Description: "Int32 int32 field",
			Optional:    true,
		},
		// Int64 int64 field
		"int64": {
			Type:        schema.TypeInt,
			Description: "Int64 int64 field",
			Optional:    true,
		},
		// Float float field
		"float": {
			Type:        schema.TypeFloat,
			Description: "Float float field",
			Optional:    true,
		},
		// Double double field
		"double": {
			Type:        schema.TypeFloat,
			Description: "Double double field",
			Optional:    true,
		},
		// Bool bool field
		"bool": {
			Type:        schema.TypeBool,
			Description: "Bool bool field",
			Optional:    true,
		},
		// Bytest byte[] field
		"bytes": {
			Type:        schema.TypeString,
			Description: "Bytest byte[] field",
			Optional:    true,
		},
		// Timestamp time.Time field
		"timestamp": {
			Type:         schema.TypeString,
			Description:  "Timestamp time.Time field",
			ValidateFunc: validation.IsRFC3339Time,
			Optional:     true,
		},
		// DurationStd time.Duration field (standard)
		"duration_std": {
			Type:        schema.TypeString,
			Description: "DurationStd time.Duration field (standard)",
			DiffSuppressFunc: func(k string, old string, new string, d *schema.ResourceData) bool {
				o, err := time.ParseDuration(old)
				if err != nil {
					return false
				}

				n, err := time.ParseDuration(new)
				if err != nil {
					return false
				}

				return o == n
			},
			Optional: true,
		},
		// DurationCustom time.Duration field (custom)
		"duration_custom": {
			Type:        schema.TypeString,
			Description: "DurationCustom time.Duration field (custom)",
			DiffSuppressFunc: func(k string, old string, new string, d *schema.ResourceData) bool {
				o, err := time.ParseDuration(old)
				if err != nil {
					return false
				}

				n, err := time.ParseDuration(new)
				if err != nil {
					return false
				}

				return o == n
			},
			Optional: true,
		},
		// TimestampN *time.Time field
		"timestamp_n": {
			Type:         schema.TypeString,
			Description:  "TimestampN *time.Time field",
			ValidateFunc: validation.IsRFC3339Time,
			Optional:     true,
		},
		// StringA []string field
		"string_a": {
			Type:        schema.TypeString,
			Description: "StringA []string field",
			Optional:    true,
		},
		// BoolA []bool field
		"bool_a": {
			Type:        schema.TypeBool,
			Description: "BoolA []bool field",
			Optional:    true,
		},
		// BytesA [][]byte field
		"bytes_a": {
			Type:        schema.TypeString,
			Description: "BytesA [][]byte field",
			Optional:    true,
		},
		// TimestampA []time.Time field
		"timestamp_a": {
			Type:         schema.TypeString,
			Description:  "TimestampA []time.Time field",
			ValidateFunc: validation.IsRFC3339Time,
			Optional:     true,
		},
		// DurationCustomA []time.Duration field
		"duration_custom_a": {
			Type:        schema.TypeString,
			Description: "DurationCustomA []time.Duration field",
			DiffSuppressFunc: func(k string, old string, new string, d *schema.ResourceData) bool {
				o, err := time.ParseDuration(old)
				if err != nil {
					return false
				}

				n, err := time.ParseDuration(new)
				if err != nil {
					return false
				}

				return o == n
			},
			Optional: true,
		},
		// Nested nested message field
		"nested": {
			Optional:    true,
			Type:        schema.TypeList,
			Description: "Nested message definition",
			MaxItems:    1,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Str string field
					"str": {
						Type:        schema.TypeString,
						Description: "Str string field",
						Optional:    true,
					},
					// Nested repeated nested messages
					"nested": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "Message nested into nested message",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Str string field
								"str": {
									Type:        schema.TypeString,
									Description: "Str string field",
									Optional:    true,
								},
							},
						},
					},
					// Nested map repeated nested messages
					"nested_m": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{

								"key": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},

								"value": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},
							},
						},
					},
					// NestedMObj nested object map
					"nested_m_obj": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{

								"key": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},
								// Message nested into nested message
								"value": {
									Optional:    true,
									Type:        schema.TypeList,
									Description: "Message nested into nested message",
									MaxItems:    1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Str string field
											"str": {
												Type:        schema.TypeString,
												Description: "Str string field",
												Optional:    true,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		// NestedA nested message array
		"nested_a": {
			Optional:    true,
			Type:        schema.TypeList,
			Description: "Nested message definition",
			MaxItems:    1,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					// Str string field
					"str": {
						Type:        schema.TypeString,
						Description: "Str string field",
						Optional:    true,
					},
					// Nested repeated nested messages
					"nested": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "Message nested into nested message",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Str string field
								"str": {
									Type:        schema.TypeString,
									Description: "Str string field",
									Optional:    true,
								},
							},
						},
					},
					// Nested map repeated nested messages
					"nested_m": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{

								"key": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},

								"value": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},
							},
						},
					},
					// NestedMObj nested object map
					"nested_m_obj": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{

								"key": {
									Type:        schema.TypeString,
									Description: "",
									Optional:    true,
								},
								// Message nested into nested message
								"value": {
									Optional:    true,
									Type:        schema.TypeList,
									Description: "Message nested into nested message",
									MaxItems:    1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Str string field
											"str": {
												Type:        schema.TypeString,
												Description: "Str string field",
												Optional:    true,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		// NestedM normal map
		"nested_m": {
			Optional:    true,
			Type:        schema.TypeList,
			Description: "",
			MaxItems:    1,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{

					"key": {
						Type:        schema.TypeString,
						Description: "",
						Optional:    true,
					},

					"value": {
						Type:        schema.TypeString,
						Description: "",
						Optional:    true,
					},
				},
			},
		},
		// NestedMObj object map
		"nested_m_obj": {
			Optional:    true,
			Type:        schema.TypeList,
			Description: "",
			MaxItems:    1,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{

					"key": {
						Type:        schema.TypeString,
						Description: "",
						Optional:    true,
					},
					// Nested message definition
					"value": {
						Optional:    true,
						Type:        schema.TypeList,
						Description: "Nested message definition",
						MaxItems:    1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								// Str string field
								"str": {
									Type:        schema.TypeString,
									Description: "Str string field",
									Optional:    true,
								},
								// Nested repeated nested messages
								"nested": {
									Optional:    true,
									Type:        schema.TypeList,
									Description: "Message nested into nested message",
									MaxItems:    1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											// Str string field
											"str": {
												Type:        schema.TypeString,
												Description: "Str string field",
												Optional:    true,
											},
										},
									},
								},
								// Nested map repeated nested messages
								"nested_m": {
									Optional:    true,
									Type:        schema.TypeList,
									Description: "",
									MaxItems:    1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{

											"key": {
												Type:        schema.TypeString,
												Description: "",
												Optional:    true,
											},

											"value": {
												Type:        schema.TypeString,
												Description: "",
												Optional:    true,
											},
										},
									},
								},
								// NestedMObj nested object map
								"nested_m_obj": {
									Optional:    true,
									Type:        schema.TypeList,
									Description: "",
									MaxItems:    1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{

											"key": {
												Type:        schema.TypeString,
												Description: "",
												Optional:    true,
											},
											// Message nested into nested message
											"value": {
												Optional:    true,
												Type:        schema.TypeList,
												Description: "Message nested into nested message",
												MaxItems:    1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														// Str string field
														"str": {
															Type:        schema.TypeString,
															Description: "Str string field",
															Optional:    true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}
func GetTestFromResourceData(d *schema.ResourceData, t *Test) error {
	p := ""

	{

		_raw, ok := d.GetOk(p + "str")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value := string(string(_raws))
			t.Str = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "int32")

		if ok {
			_raws, ok := _raw.(int)
			if !ok {
				return fmt.Errorf("can not convert %T to int", _raws)
			}
			_value := int32(int32(_raws))
			t.Int32 = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "int64")

		if ok {
			_raws, ok := _raw.(int)
			if !ok {
				return fmt.Errorf("can not convert %T to int", _raws)
			}
			_value := int64(int64(_raws))
			t.Int64 = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "float")

		if ok {
			_raws, ok := _raw.(float64)
			if !ok {
				return fmt.Errorf("can not convert %T to float64", _raws)
			}
			_value := float32(float32(_raws))
			t.Float = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "double")

		if ok {
			_raws, ok := _raw.(float64)
			if !ok {
				return fmt.Errorf("can not convert %T to float64", _raws)
			}
			_value := float64(float64(_raws))
			t.Double = _value
		}
	}
	{

		_raw, ok := d.GetOkExists(p + "bool")

		if ok {
			_raws, ok := _raw.(bool)
			if !ok {
				return fmt.Errorf("can not convert %T to bool", _raws)
			}
			_value := bool(bool(_raws))
			t.Bool = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "bytes")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value := []byte([]byte(_raws))
			t.Bytes = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "timestamp")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value, err := time.Parse(time.RFC3339Nano, _raws)
			if err != nil {
				return fmt.Errorf("malformed time value for field Timestamp : %w", err)
			}
			t.Timestamp = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "duration_std")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_valued, err := time.ParseDuration(_raws)
			if err != nil {
				return fmt.Errorf("malformed duration value for field DurationStd : %w", err)
			}
			_value := time.Duration(_valued)
			t.DurationStd = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "duration_custom")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_valued, err := time.ParseDuration(_raws)
			if err != nil {
				return fmt.Errorf("malformed duration value for field DurationCustom : %w", err)
			}
			_value := Duration(_valued)
			t.DurationCustom = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "timestamp_n")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value, err := time.Parse(time.RFC3339Nano, _raws)
			if err != nil {
				return fmt.Errorf("malformed time value for field TimestampN : %w", err)
			}
			t.TimestampN = &_value
		}
	}
	{

		_raw, ok := d.GetOk(p + "string_a")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value := string(string(_raws))
			t.StringA = _value
		}
	}
	{

		_raw, ok := d.GetOkExists(p + "bool_a")

		if ok {
			_raws, ok := _raw.(bool)
			if !ok {
				return fmt.Errorf("can not convert %T to bool", _raws)
			}
			_value := BoolCustom(bool(_raws))
			t.BoolA = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "bytes_a")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value := byte([]byte(_raws))
			t.BytesA = _value
		}
	}
	{

		_raw, ok := d.GetOk(p + "timestamp_a")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_value, err := time.Parse(time.RFC3339Nano, _raws)
			if err != nil {
				return fmt.Errorf("malformed time value for field TimestampA : %w", err)
			}
			t.TimestampA = &_value
		}
	}
	{

		_raw, ok := d.GetOk(p + "duration_custom_a")

		if ok {
			_raws, ok := _raw.(string)
			if !ok {
				return fmt.Errorf("can not convert %T to string", _raws)
			}
			_valued, err := time.ParseDuration(_raws)
			if err != nil {
				return fmt.Errorf("malformed duration value for field DurationCustomA : %w", err)
			}
			_value := Duration(_valued)
			t.DurationCustomA = _value
		}
	}
	{
		p := p + "nested" + ".0."

		_obj := Nested{}
		t.Nested = &_obj
		t := &_obj

		{

			_raw, ok := d.GetOk(p + "str")

			if ok {
				_raws, ok := _raw.(string)
				if !ok {
					return fmt.Errorf("can not convert %T to string", _raws)
				}
				_value := string(string(_raws))
				t.Str = _value
			}
		}
		{
			p := p + "nested" + ".0."

			_obj := NestedLevel2{}
			t.Nested = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "str")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.Str = _value
				}
			}

		}
		{
			p := p + "nested_m" + ".0."

			_obj := NestedMEntry{}
			t.NestedM = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "key")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.key = _value
				}
			}
			{

				_raw, ok := d.GetOk(p + "value")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.value = _value
				}
			}

		}
		{
			p := p + "nested_m_obj" + ".0."

			_obj := NestedMObjEntry{}
			t.NestedMObj = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "key")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.key = _value
				}
			}
			{
				p := p + "value" + ".0."

				_obj := NestedLevel2{}
				t.value = &_obj
				t := &_obj

				{

					_raw, ok := d.GetOk(p + "str")

					if ok {
						_raws, ok := _raw.(string)
						if !ok {
							return fmt.Errorf("can not convert %T to string", _raws)
						}
						_value := string(string(_raws))
						t.Str = _value
					}
				}

			}

		}

	}
	{
		p := p + "nested_a" + ".0."

		_obj := Nested{}
		t.NestedA = &_obj
		t := &_obj

		{

			_raw, ok := d.GetOk(p + "str")

			if ok {
				_raws, ok := _raw.(string)
				if !ok {
					return fmt.Errorf("can not convert %T to string", _raws)
				}
				_value := string(string(_raws))
				t.Str = _value
			}
		}
		{
			p := p + "nested" + ".0."

			_obj := NestedLevel2{}
			t.Nested = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "str")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.Str = _value
				}
			}

		}
		{
			p := p + "nested_m" + ".0."

			_obj := NestedMEntry{}
			t.NestedM = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "key")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.key = _value
				}
			}
			{

				_raw, ok := d.GetOk(p + "value")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.value = _value
				}
			}

		}
		{
			p := p + "nested_m_obj" + ".0."

			_obj := NestedMObjEntry{}
			t.NestedMObj = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "key")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.key = _value
				}
			}
			{
				p := p + "value" + ".0."

				_obj := NestedLevel2{}
				t.value = &_obj
				t := &_obj

				{

					_raw, ok := d.GetOk(p + "str")

					if ok {
						_raws, ok := _raw.(string)
						if !ok {
							return fmt.Errorf("can not convert %T to string", _raws)
						}
						_value := string(string(_raws))
						t.Str = _value
					}
				}

			}

		}

	}
	{
		p := p + "nested_m" + ".0."

		_obj := NestedMEntry{}
		t.NestedM = &_obj
		t := &_obj

		{

			_raw, ok := d.GetOk(p + "key")

			if ok {
				_raws, ok := _raw.(string)
				if !ok {
					return fmt.Errorf("can not convert %T to string", _raws)
				}
				_value := string(string(_raws))
				t.key = _value
			}
		}
		{

			_raw, ok := d.GetOk(p + "value")

			if ok {
				_raws, ok := _raw.(string)
				if !ok {
					return fmt.Errorf("can not convert %T to string", _raws)
				}
				_value := string(string(_raws))
				t.value = _value
			}
		}

	}
	{
		p := p + "nested_m_obj" + ".0."

		_obj := NestedMObjEntry{}
		t.NestedMObj = &_obj
		t := &_obj

		{

			_raw, ok := d.GetOk(p + "key")

			if ok {
				_raws, ok := _raw.(string)
				if !ok {
					return fmt.Errorf("can not convert %T to string", _raws)
				}
				_value := string(string(_raws))
				t.key = _value
			}
		}
		{
			p := p + "value" + ".0."

			_obj := Nested{}
			t.value = &_obj
			t := &_obj

			{

				_raw, ok := d.GetOk(p + "str")

				if ok {
					_raws, ok := _raw.(string)
					if !ok {
						return fmt.Errorf("can not convert %T to string", _raws)
					}
					_value := string(string(_raws))
					t.Str = _value
				}
			}
			{
				p := p + "nested" + ".0."

				_obj := NestedLevel2{}
				t.Nested = &_obj
				t := &_obj

				{

					_raw, ok := d.GetOk(p + "str")

					if ok {
						_raws, ok := _raw.(string)
						if !ok {
							return fmt.Errorf("can not convert %T to string", _raws)
						}
						_value := string(string(_raws))
						t.Str = _value
					}
				}

			}
			{
				p := p + "nested_m" + ".0."

				_obj := NestedMEntry{}
				t.NestedM = &_obj
				t := &_obj

				{

					_raw, ok := d.GetOk(p + "key")

					if ok {
						_raws, ok := _raw.(string)
						if !ok {
							return fmt.Errorf("can not convert %T to string", _raws)
						}
						_value := string(string(_raws))
						t.key = _value
					}
				}
				{

					_raw, ok := d.GetOk(p + "value")

					if ok {
						_raws, ok := _raw.(string)
						if !ok {
							return fmt.Errorf("can not convert %T to string", _raws)
						}
						_value := string(string(_raws))
						t.value = _value
					}
				}

			}
			{
				p := p + "nested_m_obj" + ".0."

				_obj := NestedMObjEntry{}
				t.NestedMObj = &_obj
				t := &_obj

				{

					_raw, ok := d.GetOk(p + "key")

					if ok {
						_raws, ok := _raw.(string)
						if !ok {
							return fmt.Errorf("can not convert %T to string", _raws)
						}
						_value := string(string(_raws))
						t.key = _value
					}
				}
				{
					p := p + "value" + ".0."

					_obj := NestedLevel2{}
					t.value = &_obj
					t := &_obj

					{

						_raw, ok := d.GetOk(p + "str")

						if ok {
							_raws, ok := _raw.(string)
							if !ok {
								return fmt.Errorf("can not convert %T to string", _raws)
							}
							_value := string(string(_raws))
							t.Str = _value
						}
					}

				}

			}

		}

	}

	return nil
}

func SetTestToResourceData(d *schema.ResourceData, t *Test) error {
	obj := make(map[string]interface{})

	{
		_v := t.Str

		_value := string(_v)
		obj["str"] = _value
	}
	{
		_v := t.Int32

		_value := int(_v)
		obj["int32"] = _value
	}
	{
		_v := t.Int64

		_value := int(_v)
		obj["int64"] = _value
	}
	{
		_v := t.Float

		_value := float64(_v)
		obj["float"] = _value
	}
	{
		_v := t.Double

		_value := float64(_v)
		obj["double"] = _value
	}
	{
		_v := t.Bool

		_value := bool(_v)
		obj["bool"] = _value
	}
	{
		_v := t.Bytes

		_value := string(_v)
		obj["bytes"] = _value
	}
	{
		_v := t.Timestamp

		_value := _v.Format(time.RFC3339Nano)
		obj["timestamp"] = _value
	}
	{
		_v := t.DurationStd

		_value := time.Duration(_v).String()
		obj["duration_std"] = _value
	}
	{
		_v := t.DurationCustom

		_value := time.Duration(_v).String()
		obj["duration_custom"] = _value
	}
	{
		_v := t.TimestampN
		if _v != nil {

			_value := _v.Format(time.RFC3339Nano)
			obj["timestamp_n"] = _value
		}
	}
	{
		_v := t.StringA

		_value := string(_v)
		obj["string_a"] = _value
	}
	{
		_v := t.BoolA

		_value := bool(_v)
		obj["bool_a"] = _value
	}
	{
		_v := t.BytesA

		_value := string(_v)
		obj["bytes_a"] = _value
	}
	{
		_v := t.TimestampA
		if _v != nil {

			_value := _v.Format(time.RFC3339Nano)
			obj["timestamp_a"] = _value
		}
	}
	{
		_v := t.DurationCustomA

		_value := time.Duration(_v).String()
		obj["duration_custom_a"] = _value
	}
	{

		if t.Nested != nil {

			msg := make(map[string]interface{})
			obj["nested"] = []interface{}{msg}
			{
				obj := msg
				t := t.Nested

				{
					_v := t.Str

					_value := string(_v)
					obj["str"] = _value
				}
				{

					if t.Nested != nil {

						msg := make(map[string]interface{})
						obj["nested"] = []interface{}{msg}
						{
							obj := msg
							t := t.Nested

							{
								_v := t.Str

								_value := string(_v)
								obj["str"] = _value
							}

						}

					}

				}
				{

					if t.NestedM != nil {

						msg := make(map[string]interface{})
						obj["nested_m"] = []interface{}{msg}
						{
							obj := msg
							t := t.NestedM

							{
								_v := t.key

								_value := string(_v)
								obj["key"] = _value
							}
							{
								_v := t.value

								_value := string(_v)
								obj["value"] = _value
							}

						}

					}

				}
				{

					if t.NestedMObj != nil {

						msg := make(map[string]interface{})
						obj["nested_m_obj"] = []interface{}{msg}
						{
							obj := msg
							t := t.NestedMObj

							{
								_v := t.key

								_value := string(_v)
								obj["key"] = _value
							}
							{

								if t.value != nil {

									msg := make(map[string]interface{})
									obj["value"] = []interface{}{msg}
									{
										obj := msg
										t := t.value

										{
											_v := t.Str

											_value := string(_v)
											obj["str"] = _value
										}

									}

								}

							}

						}

					}

				}

			}

		}

	}
	{

		if t.NestedA != nil {

			msg := make(map[string]interface{})
			obj["nested_a"] = []interface{}{msg}
			{
				obj := msg
				t := t.NestedA

				{
					_v := t.Str

					_value := string(_v)
					obj["str"] = _value
				}
				{

					if t.Nested != nil {

						msg := make(map[string]interface{})
						obj["nested"] = []interface{}{msg}
						{
							obj := msg
							t := t.Nested

							{
								_v := t.Str

								_value := string(_v)
								obj["str"] = _value
							}

						}

					}

				}
				{

					if t.NestedM != nil {

						msg := make(map[string]interface{})
						obj["nested_m"] = []interface{}{msg}
						{
							obj := msg
							t := t.NestedM

							{
								_v := t.key

								_value := string(_v)
								obj["key"] = _value
							}
							{
								_v := t.value

								_value := string(_v)
								obj["value"] = _value
							}

						}

					}

				}
				{

					if t.NestedMObj != nil {

						msg := make(map[string]interface{})
						obj["nested_m_obj"] = []interface{}{msg}
						{
							obj := msg
							t := t.NestedMObj

							{
								_v := t.key

								_value := string(_v)
								obj["key"] = _value
							}
							{

								if t.value != nil {

									msg := make(map[string]interface{})
									obj["value"] = []interface{}{msg}
									{
										obj := msg
										t := t.value

										{
											_v := t.Str

											_value := string(_v)
											obj["str"] = _value
										}

									}

								}

							}

						}

					}

				}

			}

		}

	}
	{

		if t.NestedM != nil {

			msg := make(map[string]interface{})
			obj["nested_m"] = []interface{}{msg}
			{
				obj := msg
				t := t.NestedM

				{
					_v := t.key

					_value := string(_v)
					obj["key"] = _value
				}
				{
					_v := t.value

					_value := string(_v)
					obj["value"] = _value
				}

			}

		}

	}
	{

		if t.NestedMObj != nil {

			msg := make(map[string]interface{})
			obj["nested_m_obj"] = []interface{}{msg}
			{
				obj := msg
				t := t.NestedMObj

				{
					_v := t.key

					_value := string(_v)
					obj["key"] = _value
				}
				{

					if t.value != nil {

						msg := make(map[string]interface{})
						obj["value"] = []interface{}{msg}
						{
							obj := msg
							t := t.value

							{
								_v := t.Str

								_value := string(_v)
								obj["str"] = _value
							}
							{

								if t.Nested != nil {

									msg := make(map[string]interface{})
									obj["nested"] = []interface{}{msg}
									{
										obj := msg
										t := t.Nested

										{
											_v := t.Str

											_value := string(_v)
											obj["str"] = _value
										}

									}

								}

							}
							{

								if t.NestedM != nil {

									msg := make(map[string]interface{})
									obj["nested_m"] = []interface{}{msg}
									{
										obj := msg
										t := t.NestedM

										{
											_v := t.key

											_value := string(_v)
											obj["key"] = _value
										}
										{
											_v := t.value

											_value := string(_v)
											obj["value"] = _value
										}

									}

								}

							}
							{

								if t.NestedMObj != nil {

									msg := make(map[string]interface{})
									obj["nested_m_obj"] = []interface{}{msg}
									{
										obj := msg
										t := t.NestedMObj

										{
											_v := t.key

											_value := string(_v)
											obj["key"] = _value
										}
										{

											if t.value != nil {

												msg := make(map[string]interface{})
												obj["value"] = []interface{}{msg}
												{
													obj := msg
													t := t.value

													{
														_v := t.Str

														_value := string(_v)
														obj["str"] = _value
													}

												}

											}

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

	for key, value := range obj {
		err := d.Set(key, value)
		if err != nil {
			return err
		}
	}

	return nil
}
